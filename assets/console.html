<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>WormJB Console</title>
<style>
:root { --bg:#0d0f11; --fg:#e5e7eb; --accent:#34d399; --err:#ef4444; --warn:#f59e0b; --info:#60a5fa; --muted:#6b7280; --bar-offset:0px; --keyboard-offset:0px; }
html.light { --bg:#ffffff; --fg:#111827; --accent:#2563eb; --err:#dc2626; --warn:#d97706; --info:#1d4ed8; --muted:#475569; }
* { box-sizing:border-box; }
body { margin:0; font:16px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; background:var(--bg); color:var(--fg); height:100dvh; display:flex; flex-direction:column; -webkit-text-size-adjust:100%; touch-action:manipulation; }
#terminal { flex:1 1 auto; overflow-y:auto; padding:58px 10px calc(96px + var(--keyboard-offset)); /* top space for toolbar */ word-wrap:break-word; }
.line { margin:0 0 4px; white-space:pre-wrap; }
.prompt-span { color:var(--accent); }
.time { color:var(--info); }
.error { color:var(--err); }
.warn { color:var(--warn); }
.muted { color:var(--muted); }
.result { color:var(--accent); }
#inputWrap { position:fixed; left:0; right:0; bottom:calc(var(--bar-offset) + var(--keyboard-offset)); background:rgba(0,0,0,0.35); backdrop-filter:blur(10px); padding:10px 12px; display:flex; align-items:center; gap:8px; }
html.light #inputWrap { background:rgba(255,255,255,0.7); }
#cmdInput { flex:1; min-height:42px; max-height:160px; resize:none; border:1px solid var(--muted); background:var(--bg); color:var(--fg); border-radius:10px; padding:10px 12px; font:16px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; line-height:1.3; }
#buttonsWrap { display:flex; gap:10px; }
.circle-btn { width:46px; height:46px; border-radius:50%; background:var(--accent); border:none; color:#fff; font-size:18px; font-weight:600; display:flex; align-items:center; justify-content:center; cursor:pointer; }
.circle-btn.secondary { background:var(--info); }
.circle-btn:active { opacity:.6; }
#toolbar { position:fixed; top:0; left:0; right:0; display:flex; gap:6px; padding:8px 10px; background:rgba(0,0,0,0.35); backdrop-filter:blur(10px); flex-wrap:wrap; }
html.light #toolbar { background:rgba(255,255,255,0.6); }
.tbtn { background:var(--muted); color:#fff; border:none; padding:4px 10px; border-radius:4px; font-size:12px; font-weight:500; }
.tbtn:active { opacity:.6; }
a { color:var(--info); text-decoration:none; }
.chunk-note { font-size:11px; color:var(--muted); }
</style>
</head>
<body>
<div id="toolbar">
  <button class="tbtn" data-cmd="clear">Clear</button>
  <button class="tbtn" data-cmd="history">History</button>
  <button class="tbtn" data-cmd="theme">Theme</button>
  <button class="tbtn" data-cmd="copy">Copy Last</button>
  <button class="tbtn" data-cmd="exit">Exit</button>
</div>
<div id="terminal"></div>
<div id="inputWrap">
  <textarea id="cmdInput" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="Enter JS"></textarea>
  <div id="buttonsWrap">
    <button id="runBtn" class="circle-btn" aria-label="Run">▶</button>
    <button id="histPrevBtn" class="circle-btn secondary" aria-label="Prev">▲</button>
    <button id="histNextBtn" class="circle-btn secondary" aria-label="Next">▼</button>
  </div>
</div>
<script>
(function(){
  const term = document.getElementById('terminal');
  const input = document.getElementById('cmdInput');
  const runBtn = document.getElementById('runBtn');
  const prevBtn = document.getElementById('histPrevBtn');
  const nextBtn = document.getElementById('histNextBtn');
  const toolbar = document.getElementById('toolbar');
  const historyKey = 'wormjb_console_history';
  let history = [];
  try { history = JSON.parse(localStorage.getItem(historyKey)||'[]'); if(!Array.isArray(history)) history=[]; } catch(e){ history=[]; }
  let histIndex = history.length;
  let lastResult = undefined;
  let theme = (localStorage.getItem('wormjb_console_theme')||'dark');
  if(theme==='light') document.documentElement.classList.add('light');
  const timers = new Map();
  const root = document.documentElement;
  const wormFileManifest = {
    '/index.html':'../index.html',
    '/README.md':'../README.md',
    '/assets/console.html':'./console.html',
    '/jb/main.sh':'../jb/main.sh',
    '/jb/liquidra1n.sh':'../jb/liquidra1n.sh',
    '/jb/WormJB.mobileconfig':'../jb/WormJB.mobileconfig',
    '/jb/loader/hookworm.sh':'../jb/loader/hookworm.sh',
    '/jb/loader/modules/test.sh':'../jb/loader/modules/test.sh',
    '/tools/apt.sh':'../tools/apt.sh',
    '/tools/ashellfetch.sh':'../tools/ashellfetch.sh',
    '/tools/worm.sh':'../tools/worm.sh',
    '/tools/wormjb.sh':'../tools/wormjb.sh'
  };
  const manifestPaths = Object.keys(wormFileManifest);
  function normalizePath(input){
    if(!input) return '/';
    let normalized = input.trim();
    if(!normalized.startsWith('/')) normalized = '/' + normalized;
    if(normalized.length>1 && normalized.endsWith('/')) normalized = normalized.slice(0,-1);
    return normalized || '/';
  }
  function directoryEntries(path){
    const normalized = normalizePath(path);
    const prefix = normalized === '/' ? '/' : normalized + '/';
    let hasMatch = normalized === '/';
    const children = new Map();
    manifestPaths.forEach(fp=>{
      if(fp === normalized) hasMatch = true;
      if(normalized !== '/' && !fp.startsWith(prefix)) return;
      if(normalized !== '/') hasMatch = true;
      if(normalized === '/' && fp === '/') return;
      const relative = normalized === '/' ? fp.slice(1) : fp.slice(prefix.length);
      if(!relative) return;
      const segments = relative.split('/');
      const name = segments[0];
      if(!name) return;
      const isDir = segments.length>1;
      const childPath = normalized === '/' ? '/' + name : normalized + '/' + name;
      if(children.has(name)) return;
      children.set(name, { name: name + (isDir?'/':''), path: childPath, type: isDir?'dir':'file' });
    });
    if(!hasMatch && children.size===0) return null;
    return Array.from(children.values()).sort((a,b)=>{
      if(a.type === b.type) return a.name.localeCompare(b.name);
      return a.type === 'dir' ? -1 : 1;
    });
  }
  const viewport = window.visualViewport;
  let focusScrollY = 0;
  let keyboardLock = false;

  function saveHistory(){ try { localStorage.setItem(historyKey, JSON.stringify(history.slice(-200))); } catch(e){} }
  function esc(s){ return String(s).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
  function print(raw, cls){ const div=document.createElement('div'); div.className='line'+(cls?(' '+cls):''); div.innerHTML=raw; term.appendChild(div); term.scrollTop=term.scrollHeight; }
  function greet(){
    print('<span class="muted">WormJB Mobile JavaScript Console</span>');
    print('<span class="muted">Copyright (c) 2025 WormJB</span>');
    print('<span class="muted">Type <b>help</b> for commands. Type <b>exit</b> to return.</span>');
    print('');
  }
  function updateKeyboardOffset(){
    if(!viewport) return;
    const keyboard = Math.max(0, (window.innerHeight - viewport.height - viewport.offsetTop));
    const eased = keyboard > 0 ? keyboard + 8 : 0;
    root.style.setProperty('--keyboard-offset', eased + 'px');
    if(keyboard>0){
      term.scrollTop = term.scrollHeight;
    }
  }
  if(viewport){
    viewport.addEventListener('resize', updateKeyboardOffset);
    viewport.addEventListener('scroll', updateKeyboardOffset);
  }
  input.addEventListener('focus',()=>{
    focusScrollY = window.scrollY || document.documentElement.scrollTop || 0;
    keyboardLock = true;
    setTimeout(()=>window.scrollTo(0, focusScrollY), 0);
    updateKeyboardOffset();
  });
  input.addEventListener('blur',()=>{
    keyboardLock = false;
    focusScrollY = 0;
    root.style.setProperty('--keyboard-offset','0px');
  });
  window.addEventListener('scroll',()=>{
    if(!keyboardLock) return;
    if(Math.abs(window.scrollY - focusScrollY) > 2){
      window.scrollTo(0, focusScrollY);
    }
  }, { passive:true });
  function formatValue(v, depth=0){
    if(v===null) return 'null';
    if(v===undefined) return 'undefined';
    if(typeof v==='string') return JSON.stringify(v);
    if(typeof v==='number'||typeof v==='boolean'||typeof v==='bigint'||typeof v==='symbol') return esc(String(v));
    if(typeof v==='function') return esc('[Function '+(v.name||'anonymous')+']');
    if(Array.isArray(v)){ if(depth>2) return esc('[Array('+v.length+')]'); return '['+v.map(x=>formatValue(x, depth+1)).join(', ')+']'; }
    if(typeof v==='object'){
      if(depth>2) return esc('{Object}');
      const keys=Object.keys(v);
      return '{'+keys.slice(0,25).map(k=>esc(k)+': '+formatValue(v[k], depth+1)).join(', ')+(keys.length>25?' …':'')+'}';
    }
    try { return esc(String(v)); } catch(e){ return esc('[Unformattable]'); }
  }
  function ensureFilePath(path){
    const normalized = normalizePath(path);
    if(!wormFileManifest[normalized]) return null;
    return normalized;
  }
  async function readFileFromManifest(path){
    const normalized = ensureFilePath(path);
    if(!normalized){ print('Unknown file: '+esc(path),'warn'); return; }
    try {
      const res = await fetch(wormFileManifest[normalized]);
      if(!res.ok) throw new Error('HTTP '+res.status);
      const text = await res.text();
      print('<span class="muted">'+esc(normalized)+'</span>');
      print('<pre class="chunk-note" style="white-space:pre-wrap;font-family:inherit;">'+esc(text)+'</pre>');
    } catch(e){
      print('Read error: '+esc(e.message||String(e)),'error');
    }
  }
  function listDirectory(path){
    const normalized = normalizePath(path);
    if(wormFileManifest[normalized]){
      print('file\u00a0'+esc(normalized));
      return;
    }
    const entries = directoryEntries(normalized);
    if(entries === null){ print('Unknown path: '+esc(path),'warn'); return; }
    if(entries.length===0){ print('Empty directory','muted'); return; }
    entries.forEach(entry=>{
      const prefix = entry.type==='dir' ? 'dir ' : 'file';
      print(prefix+'\u00a0'+esc(entry.path));
    });
  }
  function listDataKeys(){
    const keys=[];
    for(let i=0;i<localStorage.length;i++) keys.push(localStorage.key(i));
    if(!keys.length){ print('No local data found','muted'); return; }
    print('Stored keys ('+keys.length+'): '+esc(keys.join(', ')),'info');
  }
  function getDataValue(key){
    if(!key){ print('Usage: data get <key>','warn'); return; }
    const raw = localStorage.getItem(key);
    if(raw===null){ print('No value for '+esc(key),'warn'); return; }
    try {
      const parsed = JSON.parse(raw);
      print(formatValue(parsed),'result');
    } catch(e){
      print(esc(raw),'result');
    }
  }
  function setDataValue(key, value){
    if(!key){ print('Usage: data set <key> <value>','warn'); return; }
    localStorage.setItem(key, value);
    print('Saved '+esc(key),'info');
  }
  function deleteDataValue(key){
    if(!key){ print('Usage: data del <key>','warn'); return; }
    localStorage.removeItem(key);
    print('Deleted '+esc(key),'info');
  }
  function guid(){
    if(window.crypto && crypto.randomUUID) return crypto.randomUUID();
    const template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    return template.replace(/[xy]/g,c=>{
      const r=Math.random()*16|0, v=c==='x'?r:(r&0x3|0x8);
      return v.toString(16);
    });
  }
  async function mobileConfigWizard(){
    try {
      const profileName = prompt('Profile name','WormJB Remote Console');
      if(!profileName){ print('mobileconfig cancelled','warn'); return; }
      const identifier = prompt('Profile identifier','com.wormjb.console') || 'com.wormjb.console';
      const organization = prompt('Organization','WormJB Team') || 'WormJB Team';
      const webclipLabel = prompt('WebClip label','WormJB Console') || 'WormJB Console';
      const webclipURL = prompt('WebClip URL','https://wormjb.local/console') || 'https://wormjb.local/console';
      const payloadUUID = guid();
      const profileUUID = guid();
      const now = new Date().toISOString();
      const xml = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n  <key>PayloadContent</key>\n  <array>\n    <dict>\n      <key>FullScreen</key><true/>\n      <key>Icon</key><data></data>\n      <key>IsRemovable</key><true/>\n      <key>Label</key><string>${webclipLabel}</string>\n      <key>PayloadDescription</key><string>Quick launch for WormJB Console</string>\n      <key>PayloadDisplayName</key><string>WormJB Console Clip</string>\n      <key>PayloadIdentifier</key><string>${identifier}.webclip</string>\n      <key>PayloadOrganization</key><string>${organization}</string>\n      <key>PayloadType</key><string>com.apple.webClip.managed</string>\n      <key>PayloadUUID</key><string>${payloadUUID}</string>\n      <key>PayloadVersion</key><integer>1</integer>\n      <key>Precomposed</key><true/>\n      <key>URL</key><string>${webclipURL}</string>\n    </dict>\n  </array>\n  <key>PayloadDescription</key><string>Generated ${now}</string>\n  <key>PayloadDisplayName</key><string>${profileName}</string>\n  <key>PayloadIdentifier</key><string>${identifier}</string>\n  <key>PayloadOrganization</key><string>${organization}</string>\n  <key>PayloadRemovalDisallowed</key><false/>\n  <key>PayloadType</key><string>Configuration</string>\n  <key>PayloadUUID</key><string>${profileUUID}</string>\n  <key>PayloadVersion</key><integer>1</integer>\n</dict>\n</plist>`;
      const blob = new Blob([xml], { type: 'application/x-apple-aspen-config' });
      const downloadName = profileName.trim().replace(/\s+/g,'_') + '.mobileconfig';
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = downloadName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
      print('Generated '+esc(downloadName),'info');
    } catch(e){
      print('Generator failed: '+esc(e.message||String(e)),'error');
    }
  }
  async function runJS(code){
    try {
      let asyncWrapper = '(async()=>{return ('+code+')})()';
      let result;
      try { result = await eval(asyncWrapper); } catch(e){ result = await eval(code); }
      lastResult = result;
      if(result instanceof Node){ print('DOM Node: '+esc(result.nodeName), 'result'); }
      else { print(formatValue(result), 'result'); }
    } catch(e){
      print(esc(e && e.stack ? e.stack.split('\n').slice(0,4).join('\n') : (e.message||String(e))), 'error');
    }
  }
  function commandHelp(){
    print('<b>help</b> - show this help');
    print('<b>clear</b> - clear screen');
    print('<b>exit</b> - return to WormJB');
    print('<b>history</b> - show past commands');
    print('<b>time &lt;label&gt;</b> - start a timer');
    print('<b>timeEnd &lt;label&gt;</b> - end timer');
    print('<b>load &lt;url&gt;</b> - fetch & eval remote JS');
    print('<b>inspect &lt;expr&gt;</b> - detailed object dump');
    print('<b>files</b> - WormJB file utilities');
    print('<b>files ls [path]</b> - list bundled files');
    print('<b>cat &lt;path&gt;</b> - view a file');
    print('<b>data list|get|set|del</b> - manage stored data');
    print('<b>mobileconfig</b> - generate an iOS profile');
    print('<b>ls &lt;expr&gt;</b> - list enumerable keys');
    print('<b>theme &lt;dark|light&gt;</b> - switch console theme');
    print('<b>copy</b> - copy last result');
    print('<b>_</b> - reference last result value');
  }
  async function handleCommand(line){
    const trimmed=line.trim();
    if(!trimmed) return;
    if(trimmed==='help'){ commandHelp(); return; }
    if(trimmed==='clear'){ term.innerHTML=''; greet(); return; }
    if(trimmed==='exit'){ window.location.href='../index.html'; return; }
    if(trimmed==='history'){ history.forEach((h,i)=>print((i+1)+': '+esc(h))); return; }
    if(trimmed.startsWith('time ')){ const label=trimmed.slice(5); timers.set(label, performance.now()); print('Started timer '+esc(label),'time'); return; }
    if(trimmed.startsWith('timeEnd ')){ const label=trimmed.slice(8); if(timers.has(label)){ const ms=performance.now()-timers.get(label); timers.delete(label); print(label+': '+ms.toFixed(2)+'ms','time'); } else { print('No active timer '+esc(label),'warn'); } return; }
    if(trimmed.startsWith('load ')){ const url=trimmed.slice(5).trim(); try { const res= await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const txt= await res.text(); print('Loaded '+esc(url)+' ('+txt.length+' bytes)','info'); await runJS(txt); } catch(e){ print('Load error: '+esc(e.message||String(e)),'error'); } return; }
    if(trimmed.startsWith('inspect ')){ const expr=trimmed.slice(8); try { const val=eval(expr); print(formatValue(val,0),'result'); } catch(e){ print('Inspect error: '+esc(e.message||String(e)),'error'); } return; }
    if(trimmed==='files'){ listDirectory('/'); print('Use "files ls <path>" or "cat <path>"', 'muted'); return; }
    if(trimmed.startsWith('files ')){
      const [,sub,...rest] = trimmed.split(/\s+/);
      if(sub==='ls'){
        const target = rest.join(' ') || '/';
        listDirectory(target);
      } else {
        print('files commands: ls <path>','warn');
      }
      return;
    }
    if(trimmed.startsWith('cat ')){ const path = trimmed.slice(4).trim(); if(!path){ print('Usage: cat <path>','warn'); } else { await readFileFromManifest(path); } return; }
    if(trimmed==='data list'){ listDataKeys(); return; }
    if(trimmed.startsWith('data get ')){ const key=trimmed.slice(9).trim(); getDataValue(key); return; }
    if(trimmed.startsWith('data set ')){
      const pair = trimmed.slice(9).trim();
      const spaceIndex = pair.indexOf(' ');
      if(spaceIndex === -1){ print('Usage: data set <key> <value>','warn'); }
      else {
        const key = pair.slice(0, spaceIndex);
        const value = pair.slice(spaceIndex+1);
        setDataValue(key, value);
      }
      return;
    }
    if(trimmed.startsWith('data del ')){ const key=trimmed.slice(9).trim(); deleteDataValue(key); return; }
    if(trimmed==='mobileconfig'){ await mobileConfigWizard(); return; }
    if(trimmed.startsWith('ls ')){ const expr=trimmed.slice(3); try { const val=eval(expr); const keys=[]; for(const k in val) keys.push(k); print('Keys('+keys.length+'): '+esc(keys.join(', ')),'result'); } catch(e){ print('ls error: '+esc(e.message||String(e)),'error'); } return; }
    if(trimmed.startsWith('theme ')){ const mode=trimmed.slice(6).trim(); if(mode==='dark'||mode==='light'){ document.documentElement.classList.toggle('light', mode==='light'); theme=mode; localStorage.setItem('wormjb_console_theme', mode); print('Theme set to '+mode,'info'); } else { print('Theme must be dark|light','warn'); } return; }
    if(trimmed==='copy'){ if(lastResult===undefined){ print('Nothing to copy','warn'); return; } try { const txt=(typeof lastResult==='string')? lastResult : (typeof lastResult==='object'? JSON.stringify(lastResult,null,2): String(lastResult)); await navigator.clipboard.writeText(txt); print('Copied','info'); } catch(e){ print('Copy failed','error'); } return; }
    if(trimmed==='_'){ print(formatValue(lastResult),'result'); return; }
    await runJS(trimmed);
  }
  function submit(code){ if(!code.trim()) return; print('<span class="muted">»</span> '+esc(code)); history.push(code); saveHistory(); histIndex=history.length; handleCommand(code); }
  runBtn.addEventListener('click',()=>{ const v=input.value; input.value=''; submit(v); });
  input.addEventListener('keydown',e=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); const v=input.value; input.value=''; submit(v); } else if(e.key==='ArrowUp'){ e.preventDefault(); if(histIndex>0){ histIndex--; input.value=history[histIndex]||''; setTimeout(()=>input.setSelectionRange(input.value.length,input.value.length),0); } } else if(e.key==='ArrowDown'){ e.preventDefault(); if(histIndex < history.length-1){ histIndex++; input.value=history[histIndex]||''; } else { histIndex=history.length; input.value=''; } } });
  prevBtn.addEventListener('click',()=>{ const ev=new KeyboardEvent('keydown',{key:'ArrowUp'}); input.dispatchEvent(ev); });
  nextBtn.addEventListener('click',()=>{ const ev=new KeyboardEvent('keydown',{key:'ArrowDown'}); input.dispatchEvent(ev); });
  toolbar.addEventListener('click',e=>{ const t=e.target.closest('[data-cmd]'); if(!t) return; const cmd=t.getAttribute('data-cmd'); if(cmd==='clear'){ term.innerHTML=''; greet(); } else if(cmd==='history'){ history.forEach((h,i)=>print((i+1)+': '+esc(h))); } else if(cmd==='theme'){ const newMode = theme==='dark'?'light':'dark'; document.documentElement.classList.toggle('light', newMode==='light'); theme=newMode; localStorage.setItem('wormjb_console_theme', theme); print('Theme: '+theme,'info'); } else if(cmd==='copy'){ if(lastResult===undefined){ print('Nothing to copy','warn'); } else { try { const txt=(typeof lastResult==='string')? lastResult : (typeof lastResult==='object'? JSON.stringify(lastResult,null,2): String(lastResult)); navigator.clipboard.writeText(txt); print('Copied','info'); } catch(e){ print('Copy failed','error'); } } } else if(cmd==='exit'){ window.location.href='../index.html'; } });
  function autoSize(){ input.style.height='42px'; const h=Math.min(160, input.scrollHeight); input.style.height=h+'px'; }
  // Raise input bar if tall tabs enabled in main app
  (function adjustForTallTabs(){ try { const tall = localStorage.getItem('tabsNotch'); if(tall==='true' || tall===null){ document.documentElement.style.setProperty('--bar-offset','20px'); } } catch(e){} })();
  // Prevent double-tap zoom by quickly cancelling second tap (optional safeguard)
  let lastTap=0; document.addEventListener('touchend', e=>{ const now=Date.now(); if(now - lastTap < 300){ e.preventDefault(); } lastTap=now; }, {passive:false});
  input.addEventListener('input', autoSize); autoSize();
  greet(); input.focus();
  // Ensure first line is visible (scroll to top)
  term.scrollTop = 0;
})();
</script>
</body>
</html>
